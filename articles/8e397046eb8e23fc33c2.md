---
title: "è‡ªåˆ†ã® iPhone ã‹ã‚‰è‡ªåˆ†ã§è»¢é€ã—ãŸæ¥½æ›²ã‚’å–ã‚Šæˆ»ã™"
emoji: "ğŸ§"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["ios", "rust", "fuse"]
published: true
---

ã©ã†ã‚‚ã€NAS ã®ç§»è¡Œã«ä¼´ã†å…¨ãƒ‡ãƒ¼ã‚¿ç§»è¡Œå‰ã«èª¤ã£ã¦ HDD ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã—ã¦ã—ã¾ã„ã€ä¸­é«˜æ™‚ä»£ã«å–ã‚Šæºœã‚ã¦ã„ãŸæ¥½æ›²ãŒå¹ã£é£›ã‚“ã ã€ã‚ã‚Šã™ãˆã§ã™ã€‚
ä»Šå›ã¯å¤±ã£ã¦ã—ã¾ã£ãŸæ¥½æ›²ã‚’å¾©æ´»ã•ã›ã‚‹ãŸã‚ã«ã€å¿…æ­»ã« iPhone ã‹ã‚‰æ¥½æ›²ãƒ‡ãƒ¼ã‚¿ã‚’å–ã‚Šå‡ºã—ãŸè¨˜éŒ²ã§ã™ã€‚

# tl;dr

[ifuse][] ã‚’åˆ©ç”¨ã—ã¦ iPhone ã‚’ãƒã‚¦ãƒ³ãƒˆã—ã¦ Finder ã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’å¼•ã£ã“æŠœãã€‚
ãã®å¾Œ [rebuild-from-itunes-control][] ã‚’åˆ©ç”¨ã—ã¦é©åˆ‡ãªã‚¿ã‚°ä»˜ã¨é…ç½®ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã™ã‚‹ã€‚

[ifuse]: https://github.com/libimobiledevice/ifuse
[rebuild-from-itunes-control]: https://github.com/lambdalisue/rs-rebuild-from-itunes-control

# åºç« 

æ–°ã—ã„ OS ãŒãƒªãƒªãƒ¼ã‚¹ã•ã‚Œã‚‹ãŸã³ã« OS ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚’ã™ã‚‹æ–¹ã¯ä¸€å®šæ•°ä»¥ä¸Šã„ã‚‹ã¨æ€ã„ã¾ã™ã€‚ãŸã ã€äººé–“ã¯å¿˜ã‚Œã‚„ã™ã„ç”Ÿãç‰©ãªã®ã§ã€ãã†ã„ã†é‹ç”¨ã‚’ã—ã¦ã„ã‚‹ã¨å¤§ä½“ iPhone ã¨ã®åŒæœŸè¨­å®šãŒå¤–ã‚Œã¦ã—ã¾ã„ã¾ã™ã€‚
åŒæœŸè¨­å®šãŒå¤–ã‚Œã¦ã—ã¾ã†ã¨ iPhone ã®ãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã‚ˆã†ã¨ã€Œã€œã‚’ "xxxxx" ã¨åŒæœŸã€ã«ãƒã‚§ãƒƒã‚¯ã‚’å…¥ã‚Œã¦ã‚‚ã€Œå…¨ãƒ‡ãƒ¼ã‚¿æ¶ˆãˆã‚‹ã‘ã©å¤§ä¸ˆå¤«ï¼Ÿã€ã¨èã‹ã‚Œã¦å…ˆã«é€²ã‚ã¾ã›ã‚“ ğŸ˜‡

![](https://storage.googleapis.com/zenn-user-upload/9wkl8c2xuod8530rj784f9rhggzc)

æ™®æ®µãªã‚‰å®Œå…¨æ”¾ç½®ã™ã‚‹ã®ã§ã™ãŒã€ä»Šå›ã¯ iPhone ã®ã¿ãŒãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã—ã¦ã„ãŸã®ã§ä»•æ–¹ãªãå¾©æ—§æ–¹æ³•ã‚’èª¿æŸ»ã—ã¾ã—ãŸã€‚
ãã®çµæœã€ã©ã†ã‚‚ Jailbreak ã—ã¦ã„ãªã„çŠ¶æ…‹ã® iPhone ã§ã‚‚ã€ä¸€éƒ¨ã®ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚’ä½¿ã†ã“ã¨ã§ãƒ‡ãƒ¼ã‚¿ã®å¾©æ—§ãŒã§ããã†ã ã¨ã„ã†ã“ã¨ãŒåˆ¤æ˜ã—ã¾ã—ãŸã€‚
ã•ã‚‰ã«èª¿æŸ»ã‚’ç¶™ç¶šã™ã‚‹ã¨ã€å¹¸ã„ã«ã‚‚ [How to access iPhone files with a disk mount](https://reincubate.com/support/how-to/mount-iphone-files/) ã¨ã„ã†è¨˜äº‹ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã—ãŸã€‚

# iPhone ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã«ãƒã‚¦ãƒ³ãƒˆã™ã‚‹

ã“ã®ç« ã¯ [How to access iPhone files with a disk mount](https://reincubate.com/support/how-to/mount-iphone-files/) ã®è¦ç´„ã§ã™ã€‚
ã‚ˆã‚Šè©³ã—ã„æƒ…å ±ã‚’çŸ¥ã‚ŠãŸã„æ–¹ã¯ã‚ªãƒªã‚¸ãƒŠãƒ«ã«å½“ãŸã£ã¦ãã ã•ã„ã€‚

ã¾ãš FUSE ã‚’åˆ©ç”¨ã™ã‚‹ãŸã‚ [macFUSE][] ã®å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã‚ã‚‹ `osxfuse` ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚
å®Ÿéš›ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã¯ [Homebrew][] ã‚’ç”¨ã„ã¦ä»¥ä¸‹ã®ã‚ˆã†ã«è¡Œã„ã¾ã™ã€‚

[homebrew]: https://brew.sh/index_ja
[macfuse]: https://osxfuse.github.io/

```
brew install osxfuse
```

ã¡ãªã¿ã«ã€ã‚ªãƒªã‚¸ãƒŠãƒ«è¨˜äº‹ã§ã¯ tap ã—ã¦ `osxfuse` ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ã„ã¾ã™ãŒ 2021/01 ç¾åœ¨ã® Homebrew ã§ã¯ã€ãã®ã¾ã¾ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã§ããã†ã§ã—ãŸã€‚

:::message
osxfuse ã¯ FUSE for OS X -> FUSE for macOS -> macFUSE ã¨åå‰ãŒé·ç§»ã—ã¦ãŠã‚Šã€Homebrew ã‚’åˆ©ç”¨ã—ã¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ã¹ããªã®ã¯ macfuse ã§ã™ãŒ `osxfuse` ã‚’å…¥ã‚Œãªã„ã¨ ifuse ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹éš›ã«ä»¥ä¸‹ã®ã‚ˆã†ã«æ€’ã‚‰ã‚Œã¦ã—ã¾ã£ãŸãŸã‚ã€ä»•æ–¹ãªã `osxfuse` ã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™ã€‚

```
ifuse: FUSE for macOS is required for this software. OsxfuseRequirement unsatisfied!
You can install the necessary cask with:
  brew install --cask osxfuse
You can download from:
  https://osxfuse.github.io/
Error: An unsatisfied requirement failed this build.
```

ä½™è«‡ã§ã™ãŒã€MacFUSE ã®é ƒã‚’çŸ¥ã£ã¦ã„ã‚‹ã¨ macFUSE ã¨ã„ã†åå‰ã¯ä½™è¨ˆã‚„ã‚„ã“ã—ã„ã§ã™ã­ ğŸ˜…

:::

æ¬¡ã« [ifuse][] ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚
å®Ÿéš›ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã¯ `osxfuse` ã¨åŒæ§˜ã« [Homebrew][] ã‚’ç”¨ã„ã¦ä»¥ä¸‹ã®ã‚ˆã†ã«è¡Œã„ã¾ã™ã€‚

```
brew install ifuse
```

ã“ã‚Œã§ iPhone ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã¨ã—ã¦ãƒã‚¦ãƒ³ãƒˆã™ã‚‹æº–å‚™ãŒã§ãã¾ã—ãŸã€‚
ãƒã‚¦ãƒ³ãƒˆã—ãŸã„ iPhone **ã®ã¿** ã‚’ Mac ã«æ¥ç¶šã—ã€ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

```
mkdir ~/iPhone
ifuse ~/iPhone
```

ã†ã¾ãè¡Œãã¨ Finder ã§ãƒ›ãƒ¼ãƒ ã‚’è¡¨ç¤ºã—ãŸéš›ã«ä»¥ä¸‹ã®ã‚ˆã†ã« `OSXFUSE Volume 1 (ifuse)` ã¨è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚
![](https://storage.googleapis.com/zenn-user-upload/8j5dh7rvuyhj6lmw8i5e44kpteli)

ä¸­ã‚’è¦‹ã‚‹ã¨ã„ã‚ã„ã‚ã¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒã‚ã‚Šã¾ã™ãŒ `iTunes_Control/Music` ã®ä¸­èº«ã«æ¥½æ›²ãŒå…¥ã£ã¦ã„ã‚‹ã‚ˆã†ã§ã™ã€‚

![](https://storage.googleapis.com/zenn-user-upload/o7ajox1d8y09xz0qlz9hcdttls5d)

æœ¬æ¥ãªã‚‰ã“ã‚Œã§è§£æ±ºãªã®ã§ã™ãŒã€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…éƒ¨ã®åˆ†é¡ã¨ãƒ•ã‚¡ã‚¤ãƒ«åãŒäººé¡ã«ã¯æ—©ã™ãã¾ã—ãŸ ğŸ˜‡

![](https://storage.googleapis.com/zenn-user-upload/paopth40n7uhqykrkzhnw5zmwitf)

:::message

ã¡ãªã¿ã« mp3 ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚¿ã‚°ãŒæ®‹ã£ã¦ã„ãŸãŸã‚ã‚¿ã‚°ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«åã®è‡ªå‹•ç”Ÿæˆã¯ã§ããã†ã§ã—ãŸã€‚
ãŸã  m4a ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚¿ã‚°ã™ã‚‰æ›¸ãè¾¼ã¾ã‚Œã¦ã„ãªã‹ã£ãŸã®ã§è©²å½“ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å¯¾è±¡ã¨ã—ã¦ Music ã‚¢ãƒ—ãƒªã§èª­ã¿è¾¼ã‚“ã§ã‚‚é©åˆ‡ãªãƒ•ã‚¡ã‚¤ãƒ«åã«ã¯ãªã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚
:::

## `iTunes_Control` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’è§£æã™ã‚‹

å®Ÿã¯ ifuse ã«å‡ºä¼šã†å‰ã«ã„ãã¤ã‹ iPhone ã®ãƒ‡ãƒ¼ã‚¿å¾©æ—§ç”¨ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã®ãƒˆãƒ©ã‚¤ã‚¢ãƒ«ã‚’è©¦ã—ã¦ã„ã¾ã—ãŸã€‚
ãã®ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã¯æ¥½æ›²ã®æŠ½å‡ºã¯äººã«å„ªã—ã„åå‰ä»˜ã§å‡ºåŠ›ã—ã¦ã„ãŸã®ã§ã€å¿…ãšå…ƒã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã«æˆ»ã™æ–¹æ³•ãŒã‚ã‚‹ã¯ãšã§ã™ã€‚

ã¨ã„ã†ã“ã¨ã§ `iTunes_Control` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’çœºã‚ã¦ã„ã‚‹ã¨ `MediaLibrary.sqlitedb` ã¨ã„ã†ã€Œä¿ºã‚’é–‹ã„ã¦èª­ã‚“ã§ãã‚Œï¼ã€ã¨è¨€ã‚ã‚“ã°ã‹ã‚Šã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã£ãŸã®ã§è§£æã—ã¾ã—ãŸã€‚

![](https://storage.googleapis.com/zenn-user-upload/9z9uma21k1zsmie4cx7v3vb1mdit)

å†…å®¹ã‚’çœºã‚ã¦ã„ã‚‹ã¨ã€ç‰¹ã«æš—å·åŒ–ã¨ã‹ã‚‚ã•ã‚Œã¦ãŠã‚‰ãšç´ ç›´ãªæ„Ÿã˜ã® DB æ§‹é€ ã«ãªã£ã¦ã„ã¾ã—ãŸã€‚
ã¡ã‚‡ã£ã¨å¤‰ã‚ã£ã¦ã„ãŸã®ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®å®Œå…¨ãªãƒ‘ã‚¹ã¯ `base_location` ã¨ã„ã†ãƒ†ãƒ¼ãƒ–ãƒ«ã®æƒ…å ±ã¨ `item_extra` ã¨ã„ã†ãƒ†ãƒ¼ãƒ–ãƒ«ã®æƒ…å ±ã‚’åˆã‚ã›ã‚‹å¿…è¦ãŒã‚ã£ãŸç‚¹ãã‚‰ã„ã§ã™ã€‚

## Rust ã§ SQLite ã‚’èª­ã‚“ã§ã„ã„æ„Ÿã˜ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹

é©å½“ã« SQL å©ã„ã¦ã„ãŸã‚‰å¿…è¦ãªæƒ…å ±ã¯å…¨éƒ¨å–ã‚Œãã†ãªã“ã¨ãŒã‚ã‹ã£ãŸã®ã§ã€å‹‰å¼·ãŒã¦ã‚‰ Rust ã§è©²å½“ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚“ã§ã„ã„æ„Ÿã˜ã«ã‚³ãƒ”ãƒ¼ã™ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚

:::message

ä¸Šè¨˜ã®ã‚ˆã†ã« Rust ã¯è‡ªä¿¡ãŒã‚ã‚‹è¨€èªã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚è¨˜äº‹å†…ã®ã‚³ãƒ¼ãƒ‰ã®å¤‰ãªæ›¸ãæ–¹ã‚„ã€ã‚ˆã‚Šè‰¯ã„æ–¹æ³•ç­‰ãŒã‚ã‚Œã°ã”æ•™æˆã„ãŸã ã‘ã‚‹ã¨åŠ©ã‹ã‚Šã¾ã™ ğŸ™

:::

Rust ã§ DB ã¨ã„ãˆã° [Diesel][] ã§ã—ã‚‡ã†ãŒã€ä»Šå›ã¯ã¡ã‚‡ã£ã¨ã—ãŸãƒ„ãƒ¼ãƒ«ã‚’ä½œã‚‹ã ã‘ã ã£ãŸã®ã§ã€é©å½“ã«ã‚°ã‚°ã£ã¦è‰¯ã•ãã†ã ã£ãŸ [rusqlite][] ã¨ [serde_rusqlite][] ã®çµ„ã¿åˆã‚ã›ã§è¡Œãã“ã¨ã«ã—ã¾ã—ãŸã€‚

[diesel]: https://github.com/diesel-rs/diesel
[rusqlite]: https://github.com/rusqlite/rusqlite
[serde_rusqlite]: https://github.com/twistedfall/serde_rusqlite

ã¨ã‚Šã‚ãˆãš [rusqlite][] ã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã¨äº‹å‰ã«è©¦è¡ŒéŒ¯èª¤ã—ãŸ SQL ã®æƒ…å ±ã‹ã‚‰ã€ã–ã£ãã‚Šä»¥ä¸‹ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦æƒ…å ±å–å¾—ã§ãã‚‹ã‹è©¦ã—ã¦ã¿ã¾ã™ã€‚

```rust
use anyhow::Result;
use rusqlite::{Connection, NO_PARAMS};
use serde_derive::{Deserialize, Serialize};
use serde_rusqlite::*;
use std::path::Path;

#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub struct Entry {
    // item_extra
    pub title: String,
    pub location: String,
    // base_location
    pub path: String,
    // item_artist
    pub item_artist: Option<String>,
    // album
    pub album: Option<String>,
    // album_artist
    pub album_artist: Option<String>,
}

fn main() -> Result<()> {
    let home = dirs::home_dir().unwrap();
    let root = home.join("iPhone");
    let path = root.join("iTunes_Control/iTunes/MediaLibrary.sqlitedb");
    let entries = read_entries(&path)?;

    println!("{:?}", entries);

    Ok(())
}

fn read_entries(path: &Path) -> Result<Vec<Entry>> {
    let conn = Connection::open(path)?;

    let mut stmt = conn.prepare(
        r#"SELECT * FROM item
            INNER JOIN item_extra USING(item_pid)
            INNER JOIN base_location USING(base_location_id)
            LEFT JOIN item_artist USING(item_artist_pid)
            LEFT JOIN album USING(album_pid)
            LEFT JOIN album_artist USING(album_artist_pid)
            WHERE location != "" AND path != ""
        "#,
    )?;
    let items: Vec<_> = from_rows::<Entry>(stmt.query(NO_PARAMS)?)
        .flatten()
        .collect();
    Ok(items)
}
```

:::message
ãªãŠä»¥ä¸‹ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™

- `dirs`
- `anyhow`
- `rusqlite`
- `serde_derive`
- `serde_rusqlite`
  :::

æœ¬å½“ã¯ `SELECT *` ã§ã¯ãªãã€ã¡ã‚ƒã‚“ã¨æŒ‡å®šã™ã‚‹ã¹ãã§ã—ã‚‡ã†ãŒã€è©¦è¡ŒéŒ¯èª¤ã—ã¦ã„ã‚‹ã®ã§é¢å€’ã§ã™ã€‚
ã“ã†ã„ã†æ™‚ [serde_rusqlite][] ã‚’ä½¿ã£ã¦ã„ã‚‹ã¨ã€å®šç¾© (`Entry`) ã¨ã‚«ãƒ©ãƒ ã‚’å‹æ‰‹ã«ç´ã¥ã‘ãŸä¸Šã§å®šç¾©ã«å­˜åœ¨ã—ãªã„ã‚«ãƒ©ãƒ ã¯ç„¡è¦–ã—ã¦ãã‚Œã‚‹ãŸã‚ã€ã¨ã¦ã‚‚æ›¸ãå¿ƒåœ°ãŒè‰¯ã‹ã£ãŸã§ã™ã€‚

ä¸Šè¨˜ã‚’ `cargo run` ã§å®Ÿè¡Œã™ã‚‹ã¨ã€ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®æ§‹ç¯‰ã«å¿…è¦ãªæƒ…å ±ãŒã¡ã‚ƒã‚“ã¨å–ã‚Œã¦ã„ãã†ã§ã—ãŸã€‚
ãªã®ã§ä¸Šè¨˜ãƒ‡ãƒ¼ã‚¿ã‚’å…ƒã«ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚³ãƒ”ãƒ¼å…ƒã¨ã‚³ãƒ”ãƒ¼å…ˆã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã€ä»¥ä¸‹ã®ã‚ˆã†ãªé–¢æ•°ã‚’è¶³ã—ã¾ã—ãŸã€‚

```rust
fn build_src(entry: &Entry, root: &Path) -> PathBuf {
    root.join(&entry.path).join(&entry.location)
}

fn build_dst(entry: &Entry, root: &Path) -> PathBuf {
    // XXX
    // ã“ã®è¾ºå¿…è¦ä»¥ä¸Šã«è¤‡é›‘ãªæ›¸ãæ–¹ã«ãªã£ã¦ã„ã‚‹æ°—ãŒã™ã‚‹ãŒ
    // ä»–ã«è‰¯ã„æ›¸ãæ–¹ãŒæ€ã„æµ®ã‹ã°ãªã‹ã£ãŸ
    let art = entry
        .item_artist
        .as_ref()
        .map(String::to_owned)
        .unwrap_or("Unknown artist".to_string());
    let art = entry
        .album_artist
        .as_ref()
        .map(String::to_owned)
        .unwrap_or(art);
    let alb = entry
        .album
        .as_ref()
        .map(String::to_owned)
        .unwrap_or("Unknown album".to_string());
    let ext = Path::new(&entry.location)
        .extension()
        .and_then(OsStr::to_str)
        .unwrap_or("");
    root.join(art)
        .join(alb)
        .join(format!("{}.{}", &entry.title, ext))
}
```

ã‚„ã£ã¦ã„ã‚‹ã“ã¨ã¯ `entry` ã‹ã‚‰ `src/dst` ã®æ§‹ç¯‰ãªã®ã§ã€ãã‚Œã»ã©é›£ã—ããªã„ã¯ãšãªã®ã§ã™ãŒ `&Entry` å†…ã® `Option<String>` ãªå€¤ã‚’ã†ã¾ãå–ã‚Šå‡ºã™ã®ã«è‹¦åŠ´ã—ã¾ã—ãŸã€‚ã“ã®è¾ºã‚Šã€ã‚ˆã‚Šç°¡ç´ ãªæ›¸ãæ–¹ã‚’ã”å­˜çŸ¥ã®æ–¹ã¯ã”æ•™æˆã„ãŸã ã‘ã‚‹ã¨å¹¸ã„ã§ã™ã€‚
ã‚ã¨ã¯ `src` ã¨ `dst` ã‚’ä½¿ã£ã¦ã€Œãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®è‡ªå‹•ç”Ÿæˆã€ã¨ã€Œãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚³ãƒ”ãƒ¼ã€ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«è¡Œã„ã¾ã™ã€‚

```rust
if !&src.exists() {
    // ãƒ•ã‚¡ã‚¤ãƒ«ãŒãªã„å ´åˆã‚‚ã‚ã£ãŸã®ã§ã€ãã®æ™‚ã¯ã‚¹ã‚­ãƒƒãƒ—
    continue;
}
// å‡ºåŠ›ã«å¿…è¦ãªè¦ªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å…¨éƒ¨ä½œæˆ
fs::create_dir_all(&dst.parent().unwrap())?;
// ãƒ•ã‚¡ã‚¤ãƒ«ã‚³ãƒ”ãƒ¼
fs::copy(&src, &dst)?;
```

ã“ã‚Œã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ã„ã„æ„Ÿã˜ã«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚ã‘ã•ã‚ŒãŸæ¥½æ›²ãƒ•ã‚¡ã‚¤ãƒ«ãŒæ‰‹ã«å…¥ã‚Šã¾ã™ã€‚
ãŸã ã—ã€å½“ãŸã‚Šå‰ã§ã™ãŒå…ƒã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«è‡ªä½“ã«ã‚¿ã‚°æƒ…å ±ãŒã¤ã„ã¦ã„ãªã‹ã£ãŸãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯ã‚¿ã‚°æƒ…å ±ã¯ã¤ã„ã¦ã„ã¾ã›ã‚“ã€‚

:::message
ifuse ã¯ç„¡èŒ¶è‹¦èŒ¶èª­ã¿å–ã‚ŠãŒé…ã„ã®ã§ã€å®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚³ãƒ”ãƒ¼ã‚’è©¦è¡ŒéŒ¯èª¤ã™ã‚‹å‰ã«ãƒ­ãƒ¼ã‚«ãƒ«ã«ã‚³ãƒ”ãƒ¼ã—ã¦ãŠãã€ãã¡ã‚‰ã‚’åˆ©ç”¨ã—ã¦è©¦è¡ŒéŒ¯èª¤ã—ãŸæ–¹ãŒè‰¯ã„ã§ã™ã€‚
:::

## Rust ã§ SQLite ã‚’èª­ã‚“ã§ã„ã„æ„Ÿã˜ã« MP3 ã‚„ MPEG4 ã®ã‚¿ã‚°ã‚’ã¤ã‘ã‚‹

ã“ã“ã¾ã§ããŸã®ã§ `MediaLibrary.sqlitedb` ã«ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ãƒ¡ã‚¿æƒ…å ±ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚¿ã‚°æƒ…å ±ã¨ã—ã¦æ›¸ãå‡ºã™ã¨ã“ã‚ã¾ã§ã‚„ã£ã¦ã¿ã¾ã—ãŸã€‚

å¹¸ã„ãªã“ã¨ã« MP4 ãŠã‚ˆã³ MPEG4 ã®ã‚¿ã‚°æƒ…å ±ã¯ä»¥ä¸‹ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãŒä¼¼ãŸãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã†ã“ã¨ã§ç°¡å˜ã«æ›¸ãè¾¼ã‚€ã“ã¨ãŒã§ãã¾ã—ãŸã€‚

| å¯¾è±¡                                              | ãƒ©ã‚¤ãƒ–ãƒ©ãƒª        |
| ------------------------------------------------- | ----------------- |
| MP3 ãƒ•ã‚¡ã‚¤ãƒ« (ID3 metadata)                       | [rust-id3][]      |
| M4A ãƒ•ã‚¡ã‚¤ãƒ« (iTunes style MPEG-4 audio metadata) | [rust-mp4ameta][] |

[rust-id3]: https://github.com/polyfloyd/rust-id3
[rust-mp4ameta]: https://github.com/Saecki/rust-mp4ameta

MP3/M4A ã©ã¡ã‚‰ã§ã‚‚é€éçš„ã«ã‚¿ã‚°ã‚’æ›¸ãè¾¼ã‚ã‚‹ã‚ˆã†ã« `metadata` ã¨ã„ã†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä»¥ä¸‹ã®ã‚ˆã†ãªå†…å®¹ã§è¿½åŠ ã—ã¾ã—ãŸã€‚

```rust
use anyhow::{anyhow, Context, Result};
use std::ffi::OsStr;
use std::path::Path;

#[derive(Debug, PartialEq)]
pub struct Metadata {
    title: Option<String>,
    artist: Option<String>,
    album: Option<String>,
    album_artist: Option<String>,
    genre: Option<String>,
    disc: Option<u16>,
    total_discs: Option<u16>,
    track: Option<u16>,
    total_tracks: Option<u16>,
}

impl Metadata {
    pub fn new(
        title: Option<impl Into<String>>,
        artist: Option<impl Into<String>>,
        album: Option<impl Into<String>>,
        album_artist: Option<impl Into<String>>,
        genre: Option<impl Into<String>>,
        disc: Option<u16>,
        total_discs: Option<u16>,
        track: Option<u16>,
        total_tracks: Option<u16>,
    ) -> Self {
        Metadata {
            title: title.map(|v| v.into()),
            artist: artist.map(|v| v.into()),
            album: album.map(|v| v.into()),
            album_artist: album_artist.map(|v| v.into()),
            genre: genre.map(|v| v.into()),
            disc,
            total_discs,
            track,
            total_tracks,
        }
    }
}

pub fn write_metadata<P: AsRef<Path>>(path: P, meta: &Metadata) -> Result<()> {
    let path = path.as_ref();
    let ext = path.extension().and_then(OsStr::to_str);
    match ext {
        Some("mp3") => write_metadata_on_mp3(&path, &meta),
        Some("mp4") => write_metadata_on_m4a(&path, &meta),
        Some("m4a") => write_metadata_on_m4a(&path, &meta),
        Some(ext) => Err(anyhow!("Unknown file extension '{}' has specified", &ext,)),
        _ => Err(anyhow!(
            "The path '{}' does not have extension",
            &path.to_str().unwrap_or("failed to unwrap 'path'")
        )),
    }
}

fn write_metadata_on_mp3(path: &Path, meta: &Metadata) -> Result<()> {
    let mut tag = id3::Tag::read_from_path(path)?;
    meta.title.as_ref().map(|v| tag.set_title(v.to_owned()));
    meta.artist.as_ref().map(|v| tag.set_artist(v.to_owned()));
    meta.album.as_ref().map(|v| tag.set_album(v.to_owned()));
    meta.album_artist
        .as_ref()
        .map(|v| tag.set_album_artist(v.to_owned()));
    meta.genre.as_ref().map(|v| tag.set_genre(v.to_owned()));
    meta.disc.map(|v| tag.set_disc(v as u32));
    meta.total_discs.map(|v| tag.set_total_discs(v as u32));
    meta.track.map(|v| tag.set_track(v as u32));
    meta.total_tracks.map(|v| tag.set_total_tracks(v as u32));
    tag.write_to_path(path, id3::Version::Id3v24)
        .with_context(|| format!("Failed to write ID3v2.4 metadata"))
}

fn write_metadata_on_m4a(path: &Path, meta: &Metadata) -> Result<()> {
    let mut tag = mp4ameta::Tag::read_from_path(path)?;
    meta.title.as_ref().map(|v| tag.set_title(v.to_owned()));
    meta.artist.as_ref().map(|v| tag.set_artist(v.to_owned()));
    meta.album.as_ref().map(|v| tag.set_album(v.to_owned()));
    meta.album_artist
        .as_ref()
        .map(|v| tag.set_album_artist(v.to_owned()));
    meta.genre.as_ref().map(|v| tag.set_genre(v.to_owned()));
    meta.disc
        .zip(meta.total_discs)
        .map(|v| tag.set_disc(v.0, v.1));
    meta.track
        .zip(meta.total_tracks)
        .map(|v| tag.set_track(v.0, v.1));
    tag.write_to_path(path)
        .with_context(|| format!("Failed to write iTunes style MPEG-4 audio metadata"))
}
```

äºŒã¤ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãŒã‹ãªã‚Šä¼¼ã¦ã„ãŸãŸã‚ã€éå¸¸ã«ç°¡å˜ã§ã—ãŸã€‚
ãŸã ã€æœªæŒ‡å®šé …ç›®ã¯ä¸Šæ›¸ãã—ãªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã« `Option<String>` ã¨ã—ãŸãŸã‚ã€å°‘ã—æ‰±ã„ã«å°‘ã—è‹¦åŠ´ã—ã¾ã—ãŸã€‚

ä¸Šè¨˜ã®ã‚ˆã†ãªã“ã¨ã‚’è©¦è¡ŒéŒ¯èª¤ã—ãªãŒã‚‰ç°¡å˜ãªãƒ„ãƒ¼ãƒ«åŒ–ã—ãŸã‚‚ã®ãŒ

https://github.com/lambdalisue/rs-rebuild-from-itunes-control

ã¨ãªã‚Šã¾ã™ã€‚ã‚‚ã†äºŒåº¦ã¨æ¥½æ›²ã‚’å¤±ã†ã¤ã‚‚ã‚Šã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ä¸€å¿œæ±åŒ–ã—ã¾ã—ãŸ ğŸ˜‡

## ã¾ã¨ã‚

HDD ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯æ…é‡ã«
